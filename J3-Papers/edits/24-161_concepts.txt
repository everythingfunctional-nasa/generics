To: J3                                                     J3/24-161rX
From: generics
Subject: Edits for TEMPLATES: Introduction and deferred arguments
Date: 2024-October-22
References: 24-125r5, 24-126r4, 24-127r4

UTI: From Malcolm's notes: "deferred type specifier", instead of
     "deferred type"?

Introduction:
=============

This is the 1st of 6 papers that provide edits for the approved syntax
for templates. Papers 1-5 introduce a new clause titled "Templates" to
the standard. Paper 6 includes all other edits outside the new clause.

Section 1:
==========

* Insert the following text as a new clause after clause 14 Program units.


15 Templates

15.1 Template semantics

A template is a scoping unit that is parameterized by deferred
arguments and can contain declarations, specifications, and
definitions.  Instantiation of a template occurs via association of
instantiation arguments with deferred arguments and defines
non-parameterized instances of entities defined within the template.

15.2 Deferred arguments

15.2.1 Declarations of deferred arguments

15.2.1.1 General

A deferred argument is an entity whose characteristics are determined
by its effective instantiation argument.  A deferred argument can be a
constant, procedure, or type and can appear in a REQUIREMENT
construct, TEMPLATE construct, or standalone template procedure.
Association with instantiation arguments occurs in the REQUIRE and
INSTANTIATE statements.

R1501  <deferred-arg> <<is>> <deferred-const-name>
                      <<or>> <deferred-proc>
                      <<or>> <deferred-type>

C1501 (R1501) A <deferred-arg> shall appear in a <deferred-arg-decl-stmt>
              or as the <function-name> or <subroutine-name> of an
              <interface-body>.

C1502 (R1501) A <deferred-arg> shall have at most one explicit
              specification in a given scoping unit.

A deferred argument declaration statement is used to declare
deferred arguments.

R1502 <deferred-arg-decl-stmt> <<is>> <deferred-arg-explicit-stmt>
                               <<or>> <require-stmt>

R1503 <deferred-arg-explicit-stmt>
          <<is>> <deferred-type-declaration-stmt>
          <<or>> <deferred-const-declaration-stmt>
          <<or>> <deferred-proc-declaration-stmt>

NOTE

    Deferred arguments are local identifiers and are not externally
    accessible.

15.2.1.2 Deferred types

A deferred type is a deferred argument that can appear in a type
specifier within a REQUIREMENT construct, TEMPLATE construct, or
standalone template procedure.

R1504 <deferred-type-declaration-stmt> <<is>>
         TYPE, <deferred-type-attr-list> :: <deferred-type-name-list>

C1504 (R1504) Each <deferred-type-name> shall appear in the
              <deferred-arg-list> of the TEMPLATE, REQUIREMENT or
              standalone template procedure in which it appears.

R1505 <deferred-type-attr> <<is>> DEFERRED
                           <<or>> ABSTRACT
                           <<or>> EXTENSIBLE

C1505 (R1505) DEFERRED shall appear in each <deferred-type-attr-list>.

C1506 (R1505) The same <deferred-type-attr> shall not appear more than
              once in a given <deferred-type-attr-list>.

C1507 The name of a deferred type shall not appear as a
      <parent-type-name> in a <type-attr-spec>.

NOTE 1

    A deferred type cannot be extended. The use of the term EXTENSIBLE
    refers to the instantiation argument associated with the deferred
    argument, which must be extensible.

[UTI: Rename EXTENSIBLE? Perhaps DERIVED?]

A deferred type with the EXTENSIBLE attribute is an extensible derived
type. A deferred type with the ABSTRACT attribute is an abstract derived
type. A deferred type with the ABSTRACT attribute implicitly has the
EXTENSIBLE attribute, which can be confirmed with an explicit inclusion
of the EXTENSIBLE keyword in the <deferred-type-attr-list>.

[UTI: NOTE 2 is bad. From Malcolm's notes, this could useful as part of fixing
this note:
Cxxxx The name of a deferred type shall not appear as a <derived-type-spec>
      except in the <declaration-type-spec> of a <type-declaration-stmt>.
]

NOTE 2

    A deferred type is not a <type-name>.  Consequently it cannot
    appear as a <derived-type-spec>, and so a deferred type
    may not be used in a <structure-constructor>.

NOTE 3

    Examples of deferred type declarations are:

        TYPE, DEFERRED :: T1
        TYPE, DEFERRED, EXTENSIBLE :: T2
        TYPE, DEFERRED, ABSTRACT :: T3

NOTE 4

    The distinction between deferred types that are extensible or
    not, and deferred types that are abstract or not, helps to ensure
    a processor can verify a template is internally consistent.  For
    example, a deferred type must not be permitted in a CLASS
    declaration if it might be instantiated as INTEGER.  Likewise, a
    deferred type must not be permitted in a TYPE declaration if it
    might be instantiated with an abstract derived type.

    Using the deferred type declarations from NOTE 3, the following
    examples of type declaration statements are valid or invalid as
    marked:

        TYPE(T1)  :: A1   ! Valid
        CLASS(T1) :: A2   ! Invalid

        TYPE(T2)  :: B1   ! Valid
        CLASS(T2) :: B2   ! Valid

        TYPE(T3)  :: C1   ! Invalid
        CLASS(T3) :: C2   ! Valid

15.2.1.3 Deferred constants

A deferred constant is a deferred argument that can appear in constant
expressions within a REQUIREMENT construct, TEMPLATE construct, or
standalone template procedure.

R1506 <deferred-const-declaration-stmt> <<is>>
           <declaration-type-spec>, <deferred-const-attr-spec-list> ::
           <deferred-const-entity-decl-list>

R1507 <deferred-const-attr-spec> <<is>> <dimension-spec>
                                 <<or>> DEFERRED
                                 <<or>> PARAMETER
                                 <<or>> <rank-clause>

R1508 <deferred-const-entity-decl>
          <<is>> <deferred-const-name> [ ( <array-spec> ) ]

C1508 (R1507) A <deferred-const-attr-spec-list> shall include both
              the DEFERRED and PARAMETER keywords.

C1509 (R1507) An entity declared in <deferred-const-declaration-stmt>
              shall be INTEGER, LOGICAL, or assumed-length CHARACTER.

C1510 (R1508) Each <deferred-const-name> shall appear in the
              <deferred-arg-list> of the TEMPLATE, REQUIREMENT or
              standalone template procedure in which it appears.

C1511 (R1506) If <array-spec> appears in
              <deferred-const-declaration-stmt>, it shall be
              <implied-shape-spec>, <assumed-or-implied-rank-spec>,
              <explicit-shape-spec-list>, or
              <explicit-shape-bounds-spec>.

C1512 (R1506) If <implied-shape-spec>, <explicit-shape-spec> or
              <explicit-shape-bounds-spec> appears in
              <deferred-const-declaration-stmt>, then <lower-bound>
              shall not be specified.

C1513 (R1506) If <explicit-shape-bounds-spec> appears in
              <deferred-const-declaration-stmt>, then
              <explicit-bounds-expr> shall not appear as a lower bound.

NOTE 1

    Deferred constant arrays always have default lower bounds.

NOTE 2

    Examples of deferred constant declarations are:

    ! explicit shape
    INTEGER, DEFERRED, PARAMETER  :: x1
    INTEGER, DEFERRED, PARAMETER :: x2(3)
    INTEGER, PARAMETER :: v1(2) = [5,15] ! not a deferred constant
    INTEGER, DEFERRED, PARAMETER  :: x3(v1)

    ! implied shape
    INTEGER, DEFERRED, PARAMETER :: x4(*)
    INTEGER, DEFERRED, PARAMETER :: x5(*,*)
    INTEGER, DEFERRED, PARAMETER, RANK(2) :: x6

    ! assumed-or-implied-rank-spec
    INTEGER, DEFERRED, PARAMETER :: x7(..)

15.2.1.4 Deferred procedures

A deferred procedure is a deferred argument that can appear as the
procedure designator of a procedure reference
[UTI: And where else?]
within a REQUIREMENT construct, TEMPLATE construct, or standalone
template procedure.  A deferred procedure's interface shall be
established in that construct. The interface of a deferred procedure
is established by its appearance in a <deferred-proc-declaration-stmt>
or as the <subroutine-name> or <function-name> of an <interface-body>
that appears in a deferred interface block.

R1509 <deferred-proc-declaration-stmt> <<is>>
     PROCEDURE(<interface>), DEFERRED :: <deferred-proc-name-list>

C1514 (R1509) Each <deferred-proc-name> shall appear in the
              <deferred-arg-list> of the TEMPLATE, REQUIREMENT or
              standalone template procedure in which it appears.

C1515 (R1509) Each <subroutine-name> or <function-name> of an
              <interface-body> that appears in a deferred interface
              block shall appear in the <deferred-arg-list> of the
              TEMPLATE, REQUIREMENT or standalone template procedure in
              which it appears.

NOTE 1

    The interface of a deferred procedure may be defined in terms of
    other deferred arguments.

NOTE 2

    The following example declares deferred procedures F, S, and G:

        TYPE, DEFERRED :: T
        DEFERRED INTERFACE
           FUNCTION F(X)
              TYPE(T), INTENT(IN) :: X
              TYPE(T) :: F
           END FUNCTION
           SUBROUTINE S(Y)
              TYPE(T), INTENT(INOUT) :: Y
           END SUBROUTINE
        END INTERFACE
        PROCEDURE(F_I), DEFERRED :: G

===END===
